import sqlite3
import json
from langchain.tools import tool
import pandas as pd
from datetime import datetime
import uuid
import logging
import sys

# -------------------- Logger Setup --------------------
logger = logging.getLogger("tool")
logger.setLevel(logging.INFO)

# Remove any existing handlers (avoid duplicates if re-imported)
if logger.hasHandlers():
    logger.handlers.clear()

# Console handler â†’ stdout (Docker captures this)
handler = logging.StreamHandler(sys.stdout)
formatter = logging.Formatter("%(asctime)s | %(levelname)s | tool | %(message)s")
handler.setFormatter(formatter)
logger.addHandler(handler)

# Optional: prevent propagation to root logger
logger.propagate = False

# ======================================================
#                  Flight Booking Tools
# ======================================================

@tool("init_flight_bookings_db", return_direct=False)
def init_flight_bookings_db(_: str = "") -> str:
    """Initialize the bookings database and create the bookings table if it does not exist."""
    try:
        logger.info("[init_flight_bookings_db] Initializing database...")
        conn = sqlite3.connect("/app/databases/flightbookings.db")
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS bookings (
            booking_id TEXT PRIMARY KEY,
            name TEXT,
            email TEXT,
            phone TEXT,
            source TEXT,
            destination TEXT,
            date TEXT,
            flight_id TEXT,
            status TEXT
        )''')
        conn.commit()
        conn.close()
        msg = "Database initialized successfully."
        logger.info(f"[init_flight_bookings_db] {msg}")
        return msg
    except Exception as e:
        error_msg = f"[init_flight_bookings_db] Error: {str(e)}"
        logger.error(error_msg)
        return error_msg


@tool("get_flight_db_schema", return_direct=False, description="Get the schema of the Flight_Bookings database")
def get_flight_db_schema() -> str:
    """Retrieve the schema of the flight database (tables + columns)."""
    try:
        conn = sqlite3.connect(r"/app/databases/flights.db")
        c = conn.cursor()
        c.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = c.fetchall()

        schema = {}
        for t in tables:
            table_name = t[0]
            c.execute(f"PRAGMA table_info({table_name})")
            cols = c.fetchall()
            schema[table_name] = [col[1] for col in cols]

        conn.close()
        result = json.dumps(schema, indent=2)
        logger.info(f"[get_flight_db_schema] Schema: {result}")
        return result
    except Exception as e:
        error_msg = f"[get_flight_db_schema] Error: {str(e)}"
        logger.error(error_msg)
        return error_msg


@tool("generate_flight_booking_id", return_direct=False, description="Generate a unique booking ID with timestamp.")
def generate_flight_booking_id(_: str = "") -> str:
    """Generate a unique flight booking ID using timestamp and UUID."""
    try:
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        short_uuid = str(uuid.uuid4())[:8].upper()
        booking_id = f"BK{timestamp}{short_uuid}"
        logger.info(f"[generate_flight_booking_id] Generated ID: {booking_id}")
        return booking_id
    except Exception as e:
        error_msg = f"[generate_flight_booking_id] Error: {str(e)}"
        logger.error(error_msg)
        return error_msg


@tool("search_flights", return_direct=False, description="Execute raw SQL SELECT query on flights.db and return results in JSON.")
def search_flights(sql: str) -> str:
    """Execute raw SQL generated by the agent on flights.db and return results as JSON."""
    logger.info(f"[search_flights] Input SQL: {sql}")
    try:
        if not sql.strip().lower().startswith("select"):
            msg = json.dumps([{"error": "Only SELECT queries are allowed."}])
            print(f"[search_flights] Blocked non-SELECT query: {sql}")
            logger.info(f"[search_flights] Blocked non-SELECT query: {sql}")
            return msg

        conn = sqlite3.connect("/app/databases/flights.db")
        try:
            df = pd.read_sql_query(sql, conn)
            # Ensure unique column names
            seen, new_cols = {}, []
            for col in df.columns:
                if col not in seen:
                    seen[col] = 0
                    new_cols.append(col)
                else:
                    seen[col] += 1
                    new_cols.append(f"{col}_{seen[col]}")
            df.columns = new_cols

            if df.empty:
                msg = json.dumps([{"message": "No flights found for the specified criteria."}])
                logger.info(f"[search_flights] No results.")
                return msg
            print(df)
            logger.info(f"[search_flights] Retrieved {df} rows.")
            df.to_csv("/app/databases/last_query_results.csv")  # Save last results
            result = df.to_json(orient="records")
            logger.info(f"[search_flights] Results: {result[:300]}...")  # truncate for logs
            return result
        finally:
            conn.close()
    except Exception as e:
        error_msg = f"[search_flights] Error: {str(e)}"
        logger.error(error_msg)
        return json.dumps([{"error": error_msg}])


@tool("insert_flight_booking", return_direct=False, description="Insert a flight booking after collecting ALL required fields.")
def insert_flight_booking(bookingid: str, name: str, email: str, phone: str,
                          source: str, destination: str, date: str,
                          flight_id: str, status: str) -> str:
    """Save a booking to the database."""
    logger.info(f"[insert_flight_booking] Input: {locals()}")
    try:
        conn = sqlite3.connect("/app/databases/flightbookings.db")
        c = conn.cursor()
        c.execute("SELECT booking_id FROM bookings WHERE booking_id=?", (bookingid,))
        if c.fetchone():
            msg = f"Booking ID {bookingid} already exists."
            logger.warning(f"[insert_flight_booking] {msg}")
            conn.close()
            return msg

        c.execute('''INSERT INTO bookings VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)''',
                  (bookingid, name, email, phone, source, destination, date, flight_id, status))
        conn.commit()
        conn.close()
        msg = f"Booking {bookingid} saved successfully."
        logger.info(f"[insert_flight_booking] {msg}")
        return msg
    except Exception as e:
        error_msg = f"[insert_flight_booking] Error: {str(e)}"
        logger.error(error_msg)
        return error_msg


@tool("get_flight_booking_status", return_direct=False, description="Get the status of a booking by booking_id.")
def get_flight_booking_status(booking_id: str) -> str:
    """Retrieve the status of a booking by booking_id."""
    logger.info(f"[get_flight_booking_status] Input booking_id={booking_id}")
    try:
        conn = sqlite3.connect("/app/databases/flightbookings.db")
        c = conn.cursor()
        c.execute("SELECT * FROM bookings WHERE booking_id=?", (booking_id,))
        row = c.fetchone()
        conn.close()

        if row:
            keys = ["booking_id", "name", "email", "phone", "source", "destination", "date", "flight_id", "status"]
            result = json.dumps(dict(zip(keys, row)))
            logger.info(f"[get_flight_booking_status] Result: {result}")
            return result
        msg = f"No booking found for {booking_id}."
        logger.info(f"[get_flight_booking_status] {msg}")
        return msg
    except Exception as e:
        error_msg = f"[get_flight_booking_status] Error: {str(e)}"
        logger.error(error_msg)
        return error_msg


@tool("cancel_flight_booking", return_direct=False, description="Cancel a booking by booking_id.")
def cancel_flight_booking(booking_id: str) -> str:
    """Cancel a booking by booking_id."""
    logger.info(f"[cancel_flight_booking] Input booking_id={booking_id}")
    try:
        conn = sqlite3.connect("/app/databases/flightbookings.db")
        c = conn.cursor()
        c.execute("UPDATE bookings SET status='Cancelled' WHERE booking_id=?", (booking_id,))
        conn.commit()
        affected = c.rowcount
        conn.close()
        msg = f"Booking {booking_id} cancelled." if affected > 0 else f"No booking found for {booking_id}."
        logger.info(f"[cancel_flight_booking] {msg}")
        return msg
    except Exception as e:
        error_msg = f"[cancel_flight_booking] Error: {str(e)}"
        logger.error(error_msg)
        return error_msg

# ======================================================
#                  Hotel Booking Tools
# ======================================================

@tool("init_hotel_bookings_db", return_direct=False)
def init_hotel_bookings_db(_: str = "") -> str:
    """Initialize the hotel bookings database and create the bookings table if it does not exist."""
    try:
        logger.info("[init_hotel_bookings_db] Initializing database...")
        conn = sqlite3.connect("/app/databases/hotel_bookings.db")
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS hotel_bookings (
            hotelbookingid TEXT PRIMARY KEY,
            name TEXT,
            email TEXT,
            phone TEXT,
            city TEXT,
            hotel_name TEXT,
            checkin_date TEXT,
            checkout_date TEXT,
            status TEXT,
            guest_count INTEGER
        )''')
        conn.commit()
        conn.close()
        msg = "Hotel bookings database initialized successfully."
        logger.info(f"[init_hotel_bookings_db] {msg}")
        return msg
    except Exception as e:
        error_msg = f"[init_hotel_bookings_db] Error: {str(e)}"
        logger.error(error_msg)
        return error_msg


@tool("generate_hotel_booking_id", return_direct=False, description="Generate a unique hotel booking ID with timestamp.")
def generate_hotel_booking_id(_: str = "") -> str:
    """Generate a unique hotel booking ID using timestamp and UUID."""
    try:
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        short_uuid = str(uuid.uuid4())[:8].upper()
        booking_id = f"HT{timestamp}{short_uuid}"
        logger.info(f"[generate_hotel_booking_id] Generated ID: {booking_id}")
        return booking_id
    except Exception as e:
        error_msg = f"[generate_hotel_booking_id] Error: {str(e)}"
        logger.error(error_msg)
        return error_msg


@tool("get_hotel_db_schema", return_direct=False, description="Get the schema of the Hotel_Tourism database")
def get_hotel_db_schema() -> str:
    """Retrieve the schema of the hotel database (tables + columns)."""
    try:
        conn = sqlite3.connect(r"/app/databases/Hotel_Tourism.db")
        c = conn.cursor()
        c.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = c.fetchall()

        schema = {}
        for t in tables:
            table_name = t[0]
            c.execute(f"PRAGMA table_info({table_name})")
            cols = c.fetchall()
            schema[table_name] = [col[1] for col in cols]

        conn.close()
        result = json.dumps(schema, indent=2)
        logger.info(f"[get_hotel_db_schema] Schema: {result}")
        return result
    except Exception as e:
        error_msg = f"[get_hotel_db_schema] Error: {str(e)}"
        logger.error(error_msg)
        return error_msg


@tool("search_hotels", return_direct=False, description="Execute raw SQL SELECT query on Hotel_Tourism.db and return results in JSON.")
def search_hotels(sql: str) -> str:
    """Execute a raw SQL query from the agent on Hotel_Tourism.db."""
    logger.info(f"[search_hotels] Input SQL: {sql}")
    try:
        if not sql.strip().lower().startswith("select"):
            msg = json.dumps([{"error": "Only SELECT queries are allowed."}])
            logger.warning(f"[search_hotels] Blocked non-SELECT query: {sql}")
            return msg

        conn = sqlite3.connect(r"/app/databases/Hotel_Tourism.db")
        try:
            df = pd.read_sql_query(sql, conn)
            seen, new_cols = {}, []
            for col in df.columns:
                if col not in seen:
                    seen[col] = 0
                    new_cols.append(col)
                else:
                    seen[col] += 1
                    new_cols.append(f"{col}_{seen[col]}")
            df.columns = new_cols

            if df.empty:
                msg = json.dumps([{"message": "No hotels found for the specified criteria."}])
                logger.info(f"[search_hotels] No results.")
                return msg
            result = df.to_json(orient="records")
            logger.info(f"[search_hotels] Results: {result[:300]}...")
            return result
        finally:
            conn.close()
    except Exception as e:
        error_msg = f"[search_hotels] Error: {str(e)}"
        logger.error(error_msg)
        return json.dumps([{"error": error_msg}])


@tool("save_hotel_booking", return_direct=False, description="Insert a hotel booking after collecting ALL required fields.")
def save_hotel_booking(hotelbookingid: str, name: str, email: str, phone: str,
                       city: str, checkin_date: str, checkout_date: str,
                       status: str, hotel_name: str, guest_count: int) -> str:
    """Save a hotel booking to the database."""
    logger.info(f"[save_hotel_booking] Input: {locals()}")
    try:
        conn = sqlite3.connect("/app/databases/hotel_bookings.db")
        c = conn.cursor()
        c.execute("SELECT hotelbookingid FROM hotel_bookings WHERE hotelbookingid=?", (hotelbookingid,))
        if c.fetchone():
            msg = f"Booking ID {hotelbookingid} already exists."
            logger.warning(f"[save_hotel_booking] {msg}")
            conn.close()
            return msg

        c.execute('''INSERT INTO hotel_bookings 
            (hotelbookingid, name, email, phone, city, hotel_name, checkin_date, checkout_date, status, guest_count) 
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''',
            (hotelbookingid, name, email, phone, city, hotel_name, checkin_date, checkout_date, status, guest_count))
        conn.commit()
        conn.close()
        msg = f"Hotel booking {hotelbookingid} saved successfully."
        logger.info(f"[save_hotel_booking] {msg}")
        return msg
    except Exception as e:
        error_msg = f"[save_hotel_booking] Error: {str(e)}"
        logger.error(error_msg)
        return error_msg


@tool("get_hotel_booking_status", return_direct=False, description="Get the status of a hotel booking by hotelbookingid.")
def get_hotel_booking_status(hotelbookingid: str) -> str:
    """Retrieve the status and details of a hotel booking by hotelbookingid."""
    logger.info(f"[get_hotel_booking_status] Input hotelbookingid={hotelbookingid}")
    try:
        conn = sqlite3.connect("/app/databases/hotel_bookings.db")
        c = conn.cursor()
        c.execute("SELECT * FROM hotel_bookings WHERE hotelbookingid=?", (hotelbookingid,))
        row = c.fetchone()
        conn.close()

        if row:
            keys = ["hotelbookingid", "name", "email", "phone", "city", "hotel_name",
                    "checkin_date", "checkout_date", "status", "guest_count"]
            result = json.dumps(dict(zip(keys, row)))
            logger.info(f"[get_hotel_booking_status] Result: {result}")
            return result
        msg = f"No hotel booking found for {hotelbookingid}."
        logger.info(f"[get_hotel_booking_status] {msg}")
        return msg
    except Exception as e:
        error_msg = f"[get_hotel_booking_status] Error: {str(e)}"
        logger.error(error_msg)
        return error_msg


@tool("cancel_hotel_booking", return_direct=False, description="Cancel a hotel booking by hotelbookingid.")
def cancel_hotel_booking(hotelbookingid: str) -> str:
    """Cancel a hotel booking by hotelbookingid."""
    logger.info(f"[cancel_hotel_booking] Input hotelbookingid={hotelbookingid}")
    try:
        conn = sqlite3.connect("/app/databases/hotel_bookings.db")
        c = conn.cursor()
        c.execute("UPDATE hotel_bookings SET status='Cancelled' WHERE hotelbookingid=?", (hotelbookingid,))
        conn.commit()
        affected = c.rowcount
        conn.close()
        msg = f"Hotel booking {hotelbookingid} cancelled." if affected > 0 else f"No hotel booking found for {hotelbookingid}."
        logger.info(f"[cancel_hotel_booking] {msg}")
        return msg
    except Exception as e:
        error_msg = f"[cancel_hotel_booking] Error: {str(e)}"
        logger.error(error_msg)
        return error_msg
